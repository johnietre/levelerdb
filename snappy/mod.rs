// snappy/snappy.h

mod snappy_stubs_public;
pub use snappy_stubs_public::iovec;

// NOTE: All &mut are pointers in C++

// A light-weight compression algorithm. It is designed for speed of compression and
// decompression, rather than for the utmost in space savings.
//
// For getting better compression ratios when you are compressing data with long repeated
// sequences or compressing data that is similar to other data, while still compressing fast, you
// might look at first using BMDiff and then compressing the output of BMDiff with Snappy.

// ------------------------------------------------------------------------
// Generic compression/decompresion routines.
// ------------------------------------------------------------------------

// Compress the bytes read from "source" and append to "sink". Return the number of bytes
// written.
// NOTE: C++ uses Source*, Sink*
// NOTE: C++ overloads compress
pub fn compress_source(source: &mut Source, sink: &mut Sink) -> usize;

// Find the uncompressed length of the given stream, as given by the header. Note that the true
// length could deviate from this; the stream could e.g. be truncated.
//
// Also not that this leaves "source" in a state that is unsuitable for further operations, such
// as raw_uncompress(). You will need to rewind or recreate the source yourself before attempting
// any further calls.
// NOTE: C++ uses Source*, Sink*
// TODO: Return u32 and bool?
pub fn get_uncompressed_length(source: &mut Source, result: &mut u32) -> bool;

// ------------------------------------------------------------------------
// Higher-level string based routines (should be sufficient for most users)
// ------------------------------------------------------------------------

// Sets "compressed" to the compressed version of "input[0,input_length-1]". Original contents of
// "compressed" are lost.
//
// REQUIRES: "input" is not an alias of "compressed".
// NOTE: C++ uses Stirng*
pub fn compress(input: *const u8, input_length: usize, compressed: &mut String) -> usize;

// Decompress "compressed[0,compressed_length-1]" to "uncompressed". Original contents of
// "uncompressed" are lost.
//
// REQUIRES: "compressed[]" is not an alias of "uncompressed".
//
// returns false if the message is corrupted and could not be decompressed.
// NOTE: C++ uses string*
pub fn uncompress(compressed: *const u8, compressed_length: usize, uncompressed &mut String) -> bool;

// Decompress "compressed" to "uncompressed".
//
// returns false if the message is corrupted and could not be decompressed.
// NOTE: C++ uses Source* and Sink*
pub fn uncompress_source(compressed: &mut Source, uncompressed: &mut Sink) -> bool;

// This routine uncompresses as much of the "compressed" as possible into sink. It returns the
// number of valid bytes added to sink (extra invalid bytes may have been added to errors; the
// caler should ignore those). The emitted data typically has length get_uncompressed_length(),
// but may be shorter if an error is encountered.
// NOTE: C++ uses Source* and Sink*
pub fn uncompress_as_much_as_possible(compressed: &mut Source, uncompressed: &mut Sink) -> usize;

// ------------------------------------------------------------------------
// Lower-level character array based routines. May be useful for efficiency
// reasons in certain cirsumstances.
// ------------------------------------------------------------------------

// REQUIRES: "compressed" must point to an area of memory that is at least
// "max_compressed_length(input_length)" bytes in length.
//
// Takes the data stored in "input[0..input_length]" and stores it in the array pointed to by
// "compressed".
//
// "compressed_length" is set to the length of the compressed output.
//
// Example:
//    let mut output = " ".repeat(snappy::max_compressed_length(input_length));
//    let mut output_length = 0usize;
//    raw_compress(input, input_length, output, output_length.as_mut_ptr());
//    ...  process(output, output_length) ...

// Given data from the byte source "compressed[0..compressed_length-1]" generated by calling the
// snappy::compress routine, this routine stores the uncompressed data to
// "uncompressed[0..get_uncompressed_length(compressed,compressed_length)-1]".
// Returns false if the  message is corrupted and could not be decrypted.
pub fn raw_uncompress(compressed: *const u8, compressed_length: usize, uncompressed: *mut u8) -> bool;

// Given data from the byte source "compressed" generated by calling the snappy::compress_source
// routine, this routine stores the uncompressed data to
// "uncompressed[0..get_uncompressed_length(compressed,compressed_length)-1]".
// Returns false if the  message is corrupted and could not be decrypted.
// NOTE: C++ uses Source*
// NOTE: C++ overloads raw_uncompress
pub fn raw_uncompress_source(commpressed: &mut Source, uncompressed: *mut u8) -> bool;

// Given data from the byte source "compressed[0..compressed_length-1]" generated by calling the
// snappy::compress routine, this routine stores the uncompressed data to the iovec "iov". The
// number of physical buffers in "iov" is given by iov_cnt and their cumulative size must be at
// least get_uncompressed_length(compressed). The individual buffers in "iov" must not overlap
// with each other.
//
// Returns false if the message is corrupted and could not be decrypted.
pub fn raw_uncompress_to_iovec(compressed: *const u8, compressed_length: usize iov: &iovec, iov_cnt: usize) -> bool;

// Given data from the byte source "compressed" generated by calling the snappy::compress_source
// routine, this routine stores the uncompressed data to the iovec "iov". The number of physical
// buffers in "iov" is given by iov_cnt and their cumulative size must be at least
// get_uncompressed_length(compressed). The individual buffers in "iov" must not overlap with each
// other.
//
// Returns false if the message is corrupted and could not be decrypted.
// NOTE: C++ uses Source* and iovec*
// NOTE: C++ overloads raw_uncompress_to_iovec
pub fn raw_uncompress_to_iovec_source(compressed: &mut Source, iov: &iovec, iov_cnt: usize) -> bool;

// Returns the maximal size of the compressed representation of input data that is "source_bytes"
// bytes in length;
pub fn max_compressed_length(source_bytes: usize) -> usize;

// REQUIRES: "compressed" was produced by raw_compress() or compress(). Returns true and stores
// the length of the uncompressed data in "result". Returns false on parsing error.
// This operation takes O(1) time.
// NOTE: C++ uses size_t*
pub fn get_uncompressed_length(compressed: *const u8, compressed_length: usize, result: &mut usize) -> bool;

// Returns true iff the contents of "compressed" can be uncompressed successfully. Does not return
// the uncompressed data. Takes time proportional to compressed_length, but is usually at least a
// factor of four faster than actual decompression.
pub fn is_valid_compressed_buffer(compressed: *const u8, compressed_length: usize) -> bool;

// Returns true iff the contents of "compressed" can be uncompressed successfully. Does not return
// the uncompressed data. Takes time proportional to "compressed" length, but is usually at least
// a factor of four faster than actual decompression. On success, consumes all of "compressed". On
// failure, consumes an unspecified prefix of "compressed".
pub fn is_valid_compressed(compressed: &mut Source) -> bool;

// The size of a compression block. Note that many parts of the compressioni code assums that
// BLOCK_SIZE <= 65536; in particular, the hash table can only store 16-bit offsets, and
// emit_copy() also assumes the offset is 65535. Note also that if you change this, it will affect
// the framing format (see framing_format.txt).
//
// Note that there might be older data around is compressed with larger block sizes, so the
// decompression code should not rely on the non-existence of long backreferences.
// NOTE: C++ uses int
const BLOCK_LOG: usize = 16;
const BLOCK_SIZE: usize = 1 << BLOCK_LOG;

// NOTE: C++ uses int
const MIN_HASH_TABLE_BITS: usize = 8;
const MIN_HASH_TABLE_SIZE: usize = 1 << MIN_HASH_TABLE_BITS;

// NOTE: C++ uses int
const MAX_HASH_TABLE_BITS: usize = 14;
const MAX_HASH_TABLE_SIZE: usize = 1 << MAX_HASH_TABLE_BITS;
