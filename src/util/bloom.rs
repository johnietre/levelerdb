// leveldb/util/bloom.cc
// leveldb/util/bloom_test.cc

use crate::filter_policy::FilterPolicy;
use crate::hash::hash as db_hash;
use crate::slice::Slice;

// NOTE: C++ takes an int
// NOTE: C++ returns a pointer to a FilterPolicy
// NOTE: C++ forward declares this function signature in leveldb/include/leveldb/filter_policy.h
pub fn new_bloom_filter_policy(bits_per_key: usize) -> Box<dyn FilterPolicy> {
    Box::new(BloomFilterPolicy::new(bits_per_key))
}

pub struct BloomFilterPolicy {
    bits_per_key: usize,
    k: usize,
}

impl BloomFilterPolicy {
    // NOTE: C++ takes an int
    fn new(bits_per_key: usize) -> Self {
        // TODO: Figure out line below
        // Intentionally round down to reduce probing cost a little bit
        let mut k = (bits_per_key as f64 * 0.69) as usize; // 0.69 =~ ln(2)
        if k < 1 {
            k = 1;
        }
        if k > 30 {
            k = 30;
        }
        Self { bits_per_key, k }
    }
}

impl FilterPolicy for BloomFilterPolicy {
    fn name(&self) -> &'static str { "leveldb.BuiltinBloomFilter2" }

    // NOTE: C++ takes 'n' as an int
    // NOTE: 'n' possily unneeded if it will always be set to the length of 'keys'
    fn create_filter(&self, keys: &[Slice], n: usize, dst: &mut String) {
        // Compute bloom filter size (in both bits and bytes)
        let mut bits = n * self.bits_per_key;

        // For small 'n', we can see a very high false positive rate. Fix it by enfocing a minimum
        // bloom filter length.
        if bits < 64 {
            bits = 64;
        }

        let bytes = (bits + 7) / 8;
        bits = bytes * 8;

        let init_size = dst.len();
        unsafe {
            let v = dst.as_mut_vec();
            v.resize(init_size + bytes, 0);
            v.push(self.k as u8); // Remember # of probes in filter
            // NOTE: C++ code roughly translated to Rust (line below)
            //let array = &(*v)[init_size];
            let array = dst.as_mut_ptr().add(init_size);
            for i in 0..n {
                // Use double-hashing to generate a sequence of hash values.
                // See analysis in [Kirsch,Mitzenmacher 2006].
                let mut h = bloom_hash(&keys[i]);
                let delta = (h >> 17) | (h << 15); // Rotate right 17 bits
                for j in 0..self.k {
                    let bitpos = h % bits;
                    // NOTE: C++ code rougly translated to Rust (line below)
                    //array[bitpos / 8] |= (1 << (bitpos % 8));
                    *array.add(bitpos / 8) |= (1 << (bitpos % 8));
                    h += delta;
                }
            }
        }
    }

    fn key_may_match(&self, key: &Slice, bloom_filter: &Slice) -> bool {
        let len = bloom_filter.size();
        if len < 2 {
            return false;
        }
        let array = bloom_filter.data();
        let bits = (len - 1) * 8;

        unsafe {
            // Use the encoded k so that we can read filters generated by bloom filters created
            // using different params.
            let k = *array.add(len - 1);
            if k > 30 {
                return true;
            }

            let mut h = bloom_hash(key);
            let delta = (h >> 17) | (h << 15); // Rotate right 17 bits
            for j in 0..k {
                let bitpos = h % bits;
                if *array.add(bitpos / 8) & (1 << (bitpos % 8)) == 0 {
                    return false;
                }
                h += delta;
            }
        }
        true
    }
}

fn bloom_hash(key: &Slice) -> u32 {
    db_hash(key.data(), key.size(), 0xbc9f1d34)
}

#[cfg(test)]
mod tests {
    // TODO: Finish
    #![allow(unused_imports)]
    use super::*;
    use crate::util::{coding::*, logging::*, testutil::*};
    use std::mem::size_of;
    use std::os::raw::c_char;

    const VERBOSE = 1;

    // NOTE: C++ takes 'i' as int
    fn key(i: u32, buffer: *mut c_char) {
        encode_fixed32(buffer, i);
        Slice::from_raw(buffer as *const c_char, size_of::<u32>())
    }
}
